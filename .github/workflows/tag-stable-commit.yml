name: Tag stable MicroCeph commit

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main  # Change if your default branch is not "main"
  # Uncomment to enable manual and scheduled runs
  # workflow_dispatch:
  # schedule:
  #   - cron: '0 0 * * MON,THU'  # Optional: biweekly on Mondays and Thursdays

jobs:
  tag-stable-commit:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed for commit search via the API and to write a tag

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install MicroCeph snap
        run: |
          sudo snap install microceph

      - name: Extract channel information
        id: snap
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');

            const info = execSync('snap info microceph', { encoding: 'utf-8' });
            const lines = info.split('\n');
            const headerIdx = lines.findIndex(l => l.trim().startsWith('channels:'));
            if (headerIdx === -1) {
              core.setFailed('Could not find "channels:" in snap info output');
              return;
            }

            const channelRaw = lines.slice(headerIdx + 1)
              .find(l => l.includes('/stable:'));
            if (!channelRaw) {
              core.setFailed('Could not find a "/stable:" channel line');
              return;
            }

            core.info(`Channel line: "${channelRaw}"`);

            const m = channelRaw.match(
              /^\s*([a-z]+)\/stable:\s+([0-9.]+)\+snap([a-f0-9]+)\s/
            );
            if (!m) {
              core.setFailed('Failed to parse channel line');
              return;
            }

            const [, codeName, version, commit] = m;

            if (!codeName || codeName.length < 1) {
              core.setFailed(`Invalid codeName: "${codeName}"`);
              return;
            }

            if (!version || version.length < 6) {
              core.setFailed(`Invalid version: "${version}"`);
              return;
            }

            if (!commit || commit.length < 7) {
              core.setFailed(`Invalid commit: "${commit}"`);
              return;
            }

            core.setOutput('codeName', codeName);
            core.setOutput('version', version);
            core.setOutput('commit', commit);
            core.info(`codeName=${codeName}`);
            core.info(`version=${version}`);
            core.info(`commit=${commit}`);

      - name: Verify commit exists
        id: verify
        uses: actions/github-script@v7
        with:
          script: |
            const target = '${{ steps.snap.outputs.commit }}'.slice(0, 7);
            core.info(`Looking for a commit starting with "${target}" …`);

            const commits = await github.paginate(
              github.rest.repos.listCommits,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );

            const hit = commits.find(c => c.sha.startsWith(target));
            if (hit) {
              core.info(`✅ Found commit: ${hit.sha} — ${hit.html_url}`);
              const firstLine = hit.commit.message.split('\n')[0];
              core.info(`Commit message first line: "${firstLine}"`);
            } else {
              core.setFailed(`❌ No commit starting with "${target}" found in the repository`);
            }

      - name: Move latest tag to verified commit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const codeName = '${{ steps.snap.outputs.codeName }}';
            const version = '${{ steps.snap.outputs.version }}';
            const commitId = '${{ steps.snap.outputs.commit }}';
            const commitPrefix = commitId.slice(0, 7);
            const stableTag = `v${version}+${codeName}`;

            core.info(`Generated stable tag: "${stableTag}"`);

            const tags = await github.paginate(
              github.rest.repos.listTags,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );

            if (tags.length > 0) {
              const latestTag = tags[0].name;
              core.info(`Latest tag in repo: "${latestTag}"`);

              if (latestTag === stableTag) {
                core.info(`✅ Latest tag "${stableTag}" already applied. Nothing to do.`);
                return;
              }
            } else {
              core.info('No tags found. Will create the first one.');
            }

            const commits = await github.paginate(
              github.rest.repos.listCommits,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );

            const targetCommit = commits.find(c => c.sha.startsWith(commitPrefix));
            if (!targetCommit) {
              core.setFailed(`❌ Commit starting with "${commitPrefix}" not found.`);
              return;
            }

            core.info(`Found commit: ${targetCommit.sha} — ${targetCommit.html_url}`);
            const firstLine = targetCommit.commit.message.split('\n')[0];
            core.info(`Commit message first line: "${firstLine}"`);

            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${stableTag}`,
              sha: targetCommit.sha
            });

            core.info(`✅ Tag "${stableTag}" created at ${targetCommit.sha}`);
